# Dashboard API Deployment for Multi-Architecture Homelab
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: dashboard-api
  namespace: default
  labels:
    app: dashboard-api
    tier: backend
spec:
  replicas: 1
  selector:
    matchLabels:
      app: dashboard-api
  template:
    metadata:
      labels:
        app: dashboard-api
        tier: backend
      annotations:
        linkerd.io/inject: enabled
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
    spec:
      # Prefer AMD64 for API processing
      affinity:
        nodeAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            preference:
              matchExpressions:
              - key: kubernetes.io/arch
                operator: In
                values: ["amd64"]
          - weight: 50
            preference:
              matchExpressions:
              - key: kubernetes.io/arch
                operator: In
                values: ["arm64"]
      containers:
      - name: dashboard-api
        image: golang:1.21-alpine
        command: ["/bin/sh"]
        args:
        - -c
        - |
          apk add --no-cache git
          cd /tmp
          cat > main.go << 'EOF'
          package main
          
          import (
              "encoding/json"
              "fmt"
              "log"
              "net/http"
              "runtime"
              "time"
              "os/exec"
              "strings"
          )
          
          type HealthResponse struct {
              Status       string            `json:"status"`
              Timestamp    time.Time         `json:"timestamp"`
              Architecture string            `json:"architecture"`
              Version      string            `json:"version"`
              Uptime       string            `json:"uptime"`
              Services     map[string]string `json:"services"`
          }
          
          type MetricsResponse struct {
              Architecture string                 `json:"architecture"`
              Timestamp    time.Time              `json:"timestamp"`
              System       map[string]interface{} `json:"system"`
              Cluster      map[string]interface{} `json:"cluster"`
          }
          
          var startTime = time.Now()
          
          func healthHandler(w http.ResponseWriter, r *http.Request) {
              services := map[string]string{
                  "nats":         "http://nats.event-driven:8222",
                  "minio":        "http://minio.ml-serving:9000",
                  "prometheus":   "http://prometheus.flagger-system:9090",
                  "elasticsearch": "http://elasticsearch.logging:9200",
              }
              
              response := HealthResponse{
                  Status:       "healthy",
                  Timestamp:    time.Now(),
                  Architecture: runtime.GOARCH,
                  Version:      "v1.0.0",
                  Uptime:       time.Since(startTime).String(),
                  Services:     services,
              }
              
              w.Header().Set("Content-Type", "application/json")
              json.NewEncoder(w).Encode(response)
          }
          
          func metricsHandler(w http.ResponseWriter, r *http.Request) {
              // Get basic system info
              cmd := exec.Command("free", "-m")
              memOutput, _ := cmd.Output()
              
              cmd = exec.Command("df", "-h", "/")
              diskOutput, _ := cmd.Output()
              
              response := MetricsResponse{
                  Architecture: runtime.GOARCH,
                  Timestamp:    time.Now(),
                  System: map[string]interface{}{
                      "cpu_cores":     runtime.NumCPU(),
                      "goroutines":    runtime.NumGoroutine(),
                      "memory_info":   strings.TrimSpace(string(memOutput)),
                      "disk_info":     strings.TrimSpace(string(diskOutput)),
                  },
                  Cluster: map[string]interface{}{
                      "node_arch":     runtime.GOARCH,
                      "uptime":        time.Since(startTime).String(),
                      "go_version":    runtime.Version(),
                  },
              }
              
              w.Header().Set("Content-Type", "application/json")
              json.NewEncoder(w).Encode(response)
          }
          
          func main() {
              http.HandleFunc("/health", healthHandler)
              http.HandleFunc("/metrics", metricsHandler)
              http.HandleFunc("/api/health", healthHandler)
              http.HandleFunc("/api/metrics", metricsHandler)
              
              // CORS middleware
              http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
                  w.Header().Set("Access-Control-Allow-Origin", "*")
                  w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                  w.Header().Set("Access-Control-Allow-Headers", "Content-Type")
                  
                  if r.Method == "OPTIONS" {
                      return
                  }
                  
                  http.NotFound(w, r)
              })
              
              fmt.Println("Dashboard API starting on :8080")
              fmt.Printf("Architecture: %s\n", runtime.GOARCH)
              fmt.Printf("Go version: %s\n", runtime.Version())
              
              log.Fatal(http.ListenAndServe(":8080", nil))
          }
          EOF
          
          go run main.go
        ports:
        - containerPort: 8080
          name: http
        env:
        - name: NODE_ARCH
          valueFrom:
            fieldRef:
              fieldPath: metadata.labels['kubernetes.io/arch']
        resources:
          requests:
            cpu: "100m"
            memory: "128Mi"
          limits:
            cpu: "500m"
            memory: "512Mi"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: dashboard-api
  namespace: default
  labels:
    app: dashboard-api
spec:
  selector:
    app: dashboard-api
  ports:
  - name: http
    port: 8080
    targetPort: 8080
  type: ClusterIP